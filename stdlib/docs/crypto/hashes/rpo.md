Prepares the top of the stack with the hasher initial state.<br /><br />This procedures does not handle padding, therefore, the user is expected to<br />consume an amount of data which is a multiple of the rate (2 words).<br /><br />Input: []<br />Output: [PERM, PERM, PERM, ...]<br />Cycles: 12<br />
## std::crypto::hashes::rpo
| Procedure                       | Description   |
| ------------------------------- | ------------- |
| squeeze_digest                  | Given the hasher state, returns the hash output.<br /><br />Input: [C, B, A, ...]<br />Output: [HASH, ...]<br />where: For the native RPO hasher HASH is B.<br />Cycles: 9<br /> |
| absorb_double_words_from_memory | Hashes the memory `start_addr` to `end_addr` given an RPO state specified by 3 words.<br /><br />This requires that `end_addr=start_addr + 2n + 1`, otherwise the procedure will enter an infinite<br />loop. `end_addr` is not inclusive.<br /><br />Stack transition:<br />Input: [C, B, A, start_addr, end_addr, ...]<br />Output: [C', B', A', end_addr, end_addr ...]<br />Cycles: 4 + 3 * words, where `words` is the `start_addr - end_addr - 1`<br /><br />Where `A` is the capacity word that will be used by the hashing function, and `B'` the hash output.<br /> |
| hash_memory_words               | Hashes the memory `start_addr` to `end_addr`, handles odd number of elements.<br /><br />Requires `start_addr < end_addr`, `end_addr` is not inclusive.<br /><br />Stack transition:<br />Input: [start_addr, end_addr, ...]<br />Output: [H, ...]<br />Cycles:<br />even words: 49 cycles + 3 * words<br />odd words: 61 cycles + 3 * words<br /> |
| prepare_hasher_state            | Computes the hasher state required for the `hash_memory_with_state` procedure.<br /><br />Depending on the provided pad_inputs flag, this procedure instantiates the hasher state using different values for capacity element:<br />- If pad_inputs_flag equals 1 the capacity element will be assigned to 0. This will essentially "pad" the hashing values with zeroes to the next multiple of 8.<br />- If pad_inputs_flag equals 0 the capacity element will be assigned to the remainder of the division of elements number by 8 (num_elements%8).<br /><br />Inputs:  [ptr, num_elements, pad_inputs_flag]<br />Outputs: [C, B, A, ptr, end_pairs_addr, num_elements%8] |
| hash_memory_with_state          | Computes hash of Felt values starting at the specified memory address using the provided hasher state.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using `absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm` instruction.<br /><br />Inputs:  [C, B, A, ptr, end_pairs_addr, num_elements%8]<br />Outputs: [HASH]
| hash_memory                     | Computes hash of Felt values starting at the specified memory address.<br /><br />This procedure divides the hashing process into two parts: hashing pairs of words using<br />`absorb_double_words_from_memory` procedure and hashing the remaining values using the `hperm`<br />instruction.<br /><br />Inputs:  [ptr, num_elements]<br />Outputs: [HASH]<br />Cycles:<br />- If number of elements divides by 8: 47 cycles + 3 * words<br />- Else: 180 cycles + 3 * words<br /><br />Panics if number of inputs equals 0.<br /> |
